'use client';

import React, { useEffect, useRef, useState } from 'react';

// Load Orbitron font for display text
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const link = document.createElement('link');
  link.href = 'https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap';
  link.rel = 'stylesheet';
  if (!document.querySelector('link[href*="Orbitron"]')) {
    document.head.appendChild(link);
  }
}

// Global Constants - EXACT port from Python
const SCREEN_HEIGHT = 600;
const SCREEN_WIDTH = 1100;

interface Rect {
  x: number;
  y: number;
  width: number;
  height: number;
}

// Helper function for collision detection (equivalent to pygame.Rect.colliderect)
const checkCollision = (rect1: Rect, rect2: Rect): boolean => {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
};

class Dinosaur {
  static X_POS = 80;
  static Y_POS = 239;  // 380 (ground) - 141 (scaled height) = 239
  static Y_POS_DUCK = 290; // 380 (ground) - 90 (scaled duck height) = 290
  static JUMP_VEL = 8.5;

  dino_duck = false;
  dino_run = true;
  dino_jump = false;
  step_index = 0;
  jump_vel = Dinosaur.JUMP_VEL;
  dino_rect: Rect = {
    x: Dinosaur.X_POS,
    y: Dinosaur.Y_POS,
    width: 88,
    height: 94,
  };
  currentState: 'run' | 'jump' | 'duck' = 'run';

  // Sprite images
  private sprites = {
    run: [new Image(), new Image()],
    jump: new Image(),
    duck: [new Image(), new Image()],
    dead: new Image(),
    start: new Image()
  };
  private spritesLoaded = false;

  constructor() {
    // Load sprite images
    if (typeof window !== 'undefined') {
      const spritePaths = [
        { sprite: this.sprites.run[0], path: '/games/dino/DinoRun1.png' },
        { sprite: this.sprites.run[1], path: '/games/dino/DinoRun2.png' },
        { sprite: this.sprites.jump, path: '/games/dino/DinoJump.png' },
        { sprite: this.sprites.duck[0], path: '/games/dino/DinoDuck1.png' },
        { sprite: this.sprites.duck[1], path: '/games/dino/DinoDuck2.png' },
        { sprite: this.sprites.dead, path: '/games/dino/DinoDead.png' },
        { sprite: this.sprites.start, path: '/games/dino/DinoStart.png' },
      ];

      // Wait for all sprites to load
      let loadedCount = 0;
      const totalSprites = spritePaths.length;

      const checkAllLoaded = (path: string) => {
        loadedCount++;
        console.log(`Loaded sprite ${loadedCount}/${totalSprites}: ${path}`);
        if (loadedCount === totalSprites) {
          this.spritesLoaded = true;
          console.log('All dinosaur sprites loaded successfully');
        }
      };

      const handleError = (path: string) => {
        console.error(`Failed to load sprite: ${path}`);
      };

      spritePaths.forEach(({ sprite, path }) => {
        sprite.onload = () => checkAllLoaded(path);
        sprite.onerror = () => handleError(path);
        sprite.src = path;
      });
    }
  }

  update(userInput: { up: boolean; down: boolean }) {
    if (this.dino_duck) {
      this.duck();
    }
    if (this.dino_run) {
      this.run();
    }
    if (this.dino_jump) {
      this.jump();
    }

    if (this.step_index >= 10) {
      this.step_index = 0;
    }

    // Input handling - EXACT port from Python lines 66-77
    if (userInput.up && !this.dino_jump) {
      this.dino_duck = false;
      this.dino_run = false;
      this.dino_jump = true;
    } else if (userInput.down && !this.dino_jump) {
      this.dino_duck = true;
      this.dino_run = false;
      this.dino_jump = false;
    } else if (!this.dino_jump && !userInput.down) {
      this.dino_duck = false;
      this.dino_run = true;
      this.dino_jump = false;
    }
  }

  duck() {
    this.currentState = 'duck';
    this.dino_rect.x = Dinosaur.X_POS;
    this.dino_rect.y = Dinosaur.Y_POS_DUCK;
    this.dino_rect.width = 165; // 110 × 1.5
    this.dino_rect.height = 90;  // 60 × 1.5
    this.step_index += 1;
  }

  run() {
    this.currentState = 'run';
    this.dino_rect.x = Dinosaur.X_POS;
    this.dino_rect.y = Dinosaur.Y_POS;
    this.dino_rect.width = 132;  // 88 × 1.5
    this.dino_rect.height = 141; // 94 × 1.5
    this.step_index += 1;
  }

  jump() {
    this.currentState = 'jump';
    if (this.dino_jump) {
      // EXACT physics from Python line 96
      this.dino_rect.y -= this.jump_vel * 4;
      this.jump_vel -= 0.8;
    }
    // EXACT condition from Python line 98
    if (this.jump_vel < -Dinosaur.JUMP_VEL) {
      this.dino_jump = false;
      this.jump_vel = Dinosaur.JUMP_VEL;
    }
  }

  draw(ctx: CanvasRenderingContext2D) {
    // If sprites not loaded, show fallback rectangle
    if (!this.spritesLoaded) {
      ctx.fillStyle = '#404040'; // mediumGray
      ctx.fillRect(this.dino_rect.x, this.dino_rect.y, this.dino_rect.width, this.dino_rect.height);
      return;
    }

    // Draw sprite based on current state (scaled 1.5x)
    if (this.currentState === 'duck') {
      // Ducking dino - use actual dimensions (165×90)
      const frame = Math.floor(this.step_index / 5) % 2;
      ctx.drawImage(
        this.sprites.duck[frame],
        this.dino_rect.x,
        this.dino_rect.y,
        this.dino_rect.width,
        this.dino_rect.height
      );
    } else if (this.currentState === 'jump') {
      // Jumping dino - use scaled dimensions (132×141)
      ctx.drawImage(
        this.sprites.jump,
        this.dino_rect.x,
        this.dino_rect.y,
        132,
        141
      );
    } else {
      // Running dino - use scaled dimensions (132×141) with leg animation
      const frame = Math.floor(this.step_index / 5) % 2;
      ctx.drawImage(
        this.sprites.run[frame],
        this.dino_rect.x,
        this.dino_rect.y,
        132,
        141
      );
    }
  }

  drawStart(ctx: CanvasRenderingContext2D, x: number, y: number) {
    // Draw starting dino sprite
    if (this.spritesLoaded) {
      ctx.drawImage(this.sprites.start, x, y, 132, 141);
    } else {
      // Fallback rectangle
      ctx.fillStyle = '#404040'; // mediumGray
      ctx.fillRect(x, y, 132, 141);
    }
  }
}

class Cloud {
  x: number;
  y: number;
  width = 92;

  constructor() {
    // EXACT initialization from Python lines 108-110
    this.x = SCREEN_WIDTH + this.randomInt(800, 1000);
    this.y = this.randomInt(50, 100);
  }

  private randomInt(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  update(game_speed: number) {
    // EXACT logic from Python lines 114-117
    this.x -= game_speed;
    if (this.x < -this.width) {
      this.x = SCREEN_WIDTH + this.randomInt(2500, 3000);
      this.y = this.randomInt(50, 100);
    }
  }

  draw(ctx: CanvasRenderingContext2D) {
    ctx.fillStyle = '#c5c5c5';
    // Simple cloud shape
    ctx.beginPath();
    ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
    ctx.arc(this.x + 25, this.y, 25, 0, Math.PI * 2);
    ctx.arc(this.x + 50, this.y, 20, 0, Math.PI * 2);
    ctx.fill();
  }
}

abstract class Obstacle {
  rect: Rect;
  type: number;

  constructor(type: number, x: number, y: number, width: number, height: number) {
    this.type = type;
    // EXACT initialization from Python line 128
    this.rect = {
      x: SCREEN_WIDTH,
      y: y,
      width: width,
      height: height,
    };
  }

  update(game_speed: number): boolean {
    // EXACT logic from Python lines 131-133
    this.rect.x -= game_speed;
    return this.rect.x < -this.rect.width;
  }

  abstract draw(ctx: CanvasRenderingContext2D): void;
}

class SmallCactus extends Obstacle {
  private static sprites: HTMLImageElement[] = [];
  private static spritesLoaded = false;

  static {
    if (typeof window !== 'undefined') {
      for (let i = 1; i <= 3; i++) {
        const img = new Image();
        img.src = `/games/dino/SmallCactus${i}.png`;
        img.onload = () => {
          if (SmallCactus.sprites.filter(s => s.complete).length === 3) {
            SmallCactus.spritesLoaded = true;
          }
        };
        SmallCactus.sprites.push(img);
      }
    }
  }

  constructor() {
    // EXACT from Python lines 141-143
    const type = Math.floor(Math.random() * 3);
    super(type, SCREEN_WIDTH, 310, 34, 70); // 380 - 70 = 310
  }

  draw(ctx: CanvasRenderingContext2D) {
    if (SmallCactus.spritesLoaded && SmallCactus.sprites[this.type]) {
      ctx.drawImage(SmallCactus.sprites[this.type], this.rect.x, this.rect.y, this.rect.width, this.rect.height);
    } else {
      // Fallback rectangles with brand colors
      ctx.fillStyle = '#00ff88'; // accentGreen fill
      ctx.strokeStyle = '#dcdbd5'; // bodyText outline
      ctx.lineWidth = 2;
      if (this.type === 0) {
        ctx.fillRect(this.rect.x, this.rect.y, 17, 70);
        ctx.strokeRect(this.rect.x, this.rect.y, 17, 70);
      } else if (this.type === 1) {
        ctx.fillRect(this.rect.x, this.rect.y, 34, 70);
        ctx.strokeRect(this.rect.x, this.rect.y, 34, 70);
        ctx.fillRect(this.rect.x + 8, this.rect.y + 20, 17, 35);
        ctx.strokeRect(this.rect.x + 8, this.rect.y + 20, 17, 35);
      } else {
        ctx.fillRect(this.rect.x, this.rect.y, 34, 70);
        ctx.strokeRect(this.rect.x, this.rect.y, 34, 70);
        ctx.fillRect(this.rect.x, this.rect.y + 10, 17, 30);
        ctx.strokeRect(this.rect.x, this.rect.y + 10, 17, 30);
        ctx.fillRect(this.rect.x + 17, this.rect.y + 10, 17, 30);
        ctx.strokeRect(this.rect.x + 17, this.rect.y + 10, 17, 30);
      }
    }
  }
}

class LargeCactus extends Obstacle {
  private static sprites: HTMLImageElement[] = [];
  private static spritesLoaded = false;

  static {
    if (typeof window !== 'undefined') {
      for (let i = 1; i <= 3; i++) {
        const img = new Image();
        img.src = `/games/dino/LargeCactus${i}.png`;
        img.onload = () => {
          if (LargeCactus.sprites.filter(s => s.complete).length === 3) {
            LargeCactus.spritesLoaded = true;
          }
        };
        LargeCactus.sprites.push(img);
      }
    }
  }

  constructor() {
    // EXACT from Python lines 147-150
    const type = Math.floor(Math.random() * 3);
    super(type, SCREEN_WIDTH, 280, 50, 100); // 380 - 100 = 280
  }

  draw(ctx: CanvasRenderingContext2D) {
    if (LargeCactus.spritesLoaded && LargeCactus.sprites[this.type]) {
      ctx.drawImage(LargeCactus.sprites[this.type], this.rect.x, this.rect.y, this.rect.width, this.rect.height);
    } else {
      // Fallback rectangles with brand colors
      ctx.fillStyle = '#00ff88'; // accentGreen fill
      ctx.strokeStyle = '#dcdbd5'; // bodyText outline
      ctx.lineWidth = 2;
      if (this.type === 0) {
        ctx.fillRect(this.rect.x, this.rect.y, 25, 100);
        ctx.strokeRect(this.rect.x, this.rect.y, 25, 100);
        ctx.fillRect(this.rect.x + 12, this.rect.y + 20, 13, 50);
        ctx.strokeRect(this.rect.x + 12, this.rect.y + 20, 13, 50);
      } else if (this.type === 1) {
        ctx.fillRect(this.rect.x, this.rect.y, 50, 100);
        ctx.strokeRect(this.rect.x, this.rect.y, 50, 100);
        ctx.fillRect(this.rect.x + 10, this.rect.y + 30, 15, 40);
        ctx.strokeRect(this.rect.x + 10, this.rect.y + 30, 15, 40);
        ctx.fillRect(this.rect.x + 25, this.rect.y + 30, 15, 40);
        ctx.strokeRect(this.rect.x + 25, this.rect.y + 30, 15, 40);
      } else {
        ctx.fillRect(this.rect.x, this.rect.y, 25, 100);
        ctx.strokeRect(this.rect.x, this.rect.y, 25, 100);
        ctx.fillRect(this.rect.x + 25, this.rect.y, 25, 100);
        ctx.strokeRect(this.rect.x + 25, this.rect.y, 25, 100);
        ctx.fillRect(this.rect.x + 12, this.rect.y + 20, 13, 50);
        ctx.strokeRect(this.rect.x + 12, this.rect.y + 20, 13, 50);
        ctx.fillRect(this.rect.x + 25, this.rect.y + 30, 13, 40);
        ctx.strokeRect(this.rect.x + 25, this.rect.y + 30, 13, 40);
      }
    }
  }
}

class Bird extends Obstacle {
  index = 0;
  private static sprites: HTMLImageElement[] = [];
  private static spritesLoaded = false;

  static {
    if (typeof window !== 'undefined') {
      for (let i = 1; i <= 2; i++) {
        const img = new Image();
        img.src = `/games/dino/Bird${i}.png`;
        img.onload = () => {
          if (Bird.sprites.filter(s => s.complete).length === 2) {
            Bird.spritesLoaded = true;
          }
        };
        Bird.sprites.push(img);
      }
    }
  }

  constructor() {
    // EXACT from Python lines 155-157
    super(0, SCREEN_WIDTH, 250, 92, 80);
  }

  draw(ctx: CanvasRenderingContext2D) {
    // EXACT animation logic from Python lines 161-164
    if (this.index >= 9) {
      this.index = 0;
    }

    const frame = Math.floor(this.index / 5);

    if (Bird.spritesLoaded && Bird.sprites[frame]) {
      ctx.drawImage(Bird.sprites[frame], this.rect.x, this.rect.y, this.rect.width, this.rect.height);
    } else {
      // Fallback rectangles with brand color
      ctx.fillStyle = '#dcdbd5'; // bodyText color
      // Bird body
      ctx.fillRect(this.rect.x + 10, this.rect.y + 30, 60, 30);
      // Wing animation
      if (frame === 0) {
        ctx.fillRect(this.rect.x, this.rect.y + 20, 80, 20);
      } else {
        ctx.fillRect(this.rect.x + 5, this.rect.y + 35, 70, 15);
      }
      // Beak
      ctx.fillRect(this.rect.x + 60, this.rect.y + 35, 15, 10);
    }

    this.index += 1;
  }
}

const DinoGame: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [gameState, setGameState] = useState<'menu' | 'playing' | 'gameover'>('menu');
  const [deathCount, setDeathCount] = useState(0);
  const [finalScore, setFinalScore] = useState(0);

  // Create a persistent player instance for menu rendering
  const menuPlayerRef = useRef<Dinosaur | null>(null);
  if (!menuPlayerRef.current) {
    menuPlayerRef.current = new Dinosaur();
  }

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Game variables - EXACT from Python lines 173-179
    let game_speed = 20;
    let x_pos_bg = 0;
    const y_pos_bg = 380;
    let points = 0;
    let obstacles: Obstacle[] = [];

    const player = new Dinosaur();
    const cloud = new Cloud();

    // Input state
    const userInput = { up: false, down: false };

    // Event listeners for keyboard
    const handleKeyDown = (e: KeyboardEvent) => {
      if (gameState === 'menu') {
        setGameState('playing');
        return;
      }
      if (gameState === 'playing') {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          userInput.up = true;
        }
        if (e.code === 'ArrowDown') {
          e.preventDefault();
          userInput.down = true;
        }
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        userInput.up = false;
      }
      if (e.code === 'ArrowDown') {
        userInput.down = false;
      }
    };

    // Touch/click support for mobile
    const handleTouch = () => {
      if (gameState === 'menu') {
        setGameState('playing');
      } else if (gameState === 'playing') {
        userInput.up = true;
        setTimeout(() => {
          userInput.up = false;
        }, 100);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('click', handleTouch);
    canvas.addEventListener('touchstart', handleTouch);

    // Score function - EXACT from Python lines 181-190
    const drawScore = () => {
      points += 1;
      if (points % 100 === 0) {
        game_speed += 1;
      }

      ctx.fillStyle = '#000000';
      ctx.font = 'bold 28px Orbitron, Arial'; // H3 display text
      ctx.textAlign = 'right';
      ctx.fillText(`Points: ${points}`, SCREEN_WIDTH - 100, 40);
    };

    // Background function - EXACT from Python lines 192-200
    const drawBackground = () => {
      const image_width = SCREEN_WIDTH;

      // Draw ground with mediumGray color
      ctx.fillStyle = '#404040'; // mediumGray
      ctx.fillRect(0, y_pos_bg, SCREEN_WIDTH, 2);

      // Scrolling effect
      if (x_pos_bg <= -image_width) {
        x_pos_bg = 0;
      }
      x_pos_bg -= game_speed;
    };

    // Game loop - EXACT logic from Python lines 202-237
    const gameLoop = () => {
      if (gameState !== 'playing') return;

      // Clear screen - EXACT from Python line 207
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

      // Update and draw player
      player.draw(ctx);
      player.update(userInput);

      // Obstacle spawning - EXACT logic from Python lines 213-219
      if (obstacles.length === 0) {
        const rand = Math.floor(Math.random() * 3);
        if (rand === 0) {
          obstacles.push(new SmallCactus());
        } else if (rand === 1) {
          obstacles.push(new LargeCactus());
        } else if (rand === 2) {
          obstacles.push(new Bird());
        }
      }

      // Update and draw obstacles - EXACT from Python lines 221-227
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        obstacle.draw(ctx);
        const shouldRemove = obstacle.update(game_speed);

        if (shouldRemove) {
          obstacles.splice(i, 1);
        }

        // Collision detection - EXACT from Python line 224
        if (checkCollision(player.dino_rect, obstacle.rect)) {
          setFinalScore(points);
          setDeathCount(prev => prev + 1);
          setGameState('gameover');
          return;
        }
      }

      // Draw background
      drawBackground();

      // Draw cloud
      cloud.draw(ctx);
      cloud.update(game_speed);

      // Draw score
      drawScore();
    };

    // Main game loop with EXACT timing from Python line 236
    let animationId: number;
    const frame = () => {
      gameLoop();
      animationId = requestAnimationFrame(frame);
    };

    if (gameState === 'playing') {
      animationId = requestAnimationFrame(frame);
    }

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      canvas.removeEventListener('click', handleTouch);
      canvas.removeEventListener('touchstart', handleTouch);
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [gameState]);

  // Menu screen - EXACT from Python lines 240-266
  const renderMenu = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    ctx.fillStyle = '#000000';
    ctx.font = 'bold 36px Orbitron, Arial';
    ctx.textAlign = 'center';

    if (deathCount === 0) {
      ctx.fillText('Press any Key to Start', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
    } else {
      ctx.fillText('Press any Key to Restart', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
      ctx.font = 'bold 28px Orbitron, Arial';
      ctx.fillText(`Your Score: ${finalScore}`, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 50);
    }

    // Draw dino start sprite (centered, 1.5x scale)
    if (menuPlayerRef.current) {
      menuPlayerRef.current.drawStart(ctx, SCREEN_WIDTH / 2 - 66, SCREEN_HEIGHT / 2 - 140);
    }
  };

  useEffect(() => {
    if (gameState === 'menu' || gameState === 'gameover') {
      renderMenu();
    }
  }, [gameState, deathCount, finalScore]);

  return (
    <div>
      <canvas
        ref={canvasRef}
        width={SCREEN_WIDTH}
        height={SCREEN_HEIGHT}
        className="cursor-pointer"
        style={{ display: 'block', margin: '0 auto' }}
      />
    </div>
  );
};

export default DinoGame;
