name: Deploy to Cloudflare Pages

on:
  # Trigger from n8n workflow
  repository_dispatch:
    types: [deploy-wordpress-content]

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      post_id:
        description: 'WordPress Post ID'
        required: false
      post_slug:
        description: 'WordPress Post Slug'
        required: false
      deployment_type:
        description: 'Deployment type'
        required: false
        default: 'incremental'
        type: choice
        options:
          - incremental
          - full
      skip_build_cache:
        description: 'Skip build cache'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  CLOUDFLARE_PROJECT_NAME: 'saa-static'  # Static export project
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes in seconds
  MAX_PARALLEL_UPLOADS: 50
  RETRY_ATTEMPTS: 3
  RETRY_DELAY: 5

jobs:
  # Build job - creates the static export
  build:
    name: Build Static Export
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      build-hash: ${{ steps.compute-hash.outputs.build-hash }}
      needs-deploy: ${{ steps.check-changes.outputs.needs-deploy }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ./nextjs-frontend/package-lock.json

      # Cache node_modules
      - name: Cache node_modules
        if: ${{ !inputs.skip_build_cache }}
        uses: actions/cache@v4
        id: node-modules-cache
        with:
          path: ./nextjs-frontend/node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('./nextjs-frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      # Cache Next.js build
      - name: Cache Next.js build
        if: ${{ !inputs.skip_build_cache }}
        uses: actions/cache@v4
        with:
          path: |
            ./nextjs-frontend/.next/cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('./nextjs-frontend/package-lock.json') }}-${{ hashFiles('./nextjs-frontend/**/*.js', './nextjs-frontend/**/*.jsx', './nextjs-frontend/**/*.ts', './nextjs-frontend/**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('./nextjs-frontend/package-lock.json') }}-
            ${{ runner.os }}-nextjs-

      # Install dependencies
      - name: Install dependencies
        working-directory: ./nextjs-frontend
        run: |
          if [ "${{ steps.node-modules-cache.outputs.cache-hit }}" != "true" ]; then
            echo "üì¶ Installing dependencies..."
            npm ci --prefer-offline --no-audit
          else
            echo "‚úÖ Using cached node_modules"
          fi

      # Generate Master Controller CSS from Supabase settings
      - name: Generate Master Controller CSS
        working-directory: ./nextjs-frontend
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        run: |
          echo "üé® Generating build-time CSS from Master Controller settings..."

          # Generate CSS from Supabase
          npm run generate:css

          # Verify CSS was created
          if [ -f "public/static-master-controller.css" ]; then
            echo "‚úÖ CSS generated successfully"
            ls -lh public/static-master-controller.css
          else
            echo "‚ö†Ô∏è  CSS file not found - using default styles"
          fi

      # Build static export with config file swap
      - name: Build Static Export
        working-directory: ./nextjs-frontend
        env:
          NODE_ENV: production
          # Supabase credentials for build-time data fetching (read-only)
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          # WordPress API for blog content
          WORDPRESS_API_URL: ${{ secrets.WORDPRESS_API_URL }}
          NEXT_PUBLIC_WORDPRESS_API_URL: ${{ secrets.NEXT_PUBLIC_WORDPRESS_API_URL }}
        run: |
          echo "üî® Building static export with Next.js natural exclusion"
          echo "   Temporarily using next.config.static-export.ts (output: 'export')"
          echo "   Next.js will automatically skip API routes"
          echo ""

          # Swap to static export config
          mv next.config.ts next.config.ts.backup
          cp next.config.export.ts next.config.ts

          # Build with static export config (Next.js excludes API routes automatically)
          npm run build

          # Restore original config
          mv next.config.ts.backup next.config.ts

          echo ""
          echo "üìä Build verification:"
          echo "  Files to deploy: $(find out -type f | wc -l)"
          echo "  Total size: $(du -sh out/ | cut -f1)"

          # Verify critical files exist
          test -d out/_next || { echo "‚ùå _next directory missing"; exit 1; }
          test -f out/index.html || { echo "‚ùå index.html missing"; exit 1; }
          test -f out/static-master-controller.css || echo "‚ö†Ô∏è CSS missing (non-fatal)"

          echo "‚úÖ Static export complete - ready for Cloudflare Pages deployment"

      # Compute build hash for change detection
      - name: Compute build hash
        id: compute-hash
        working-directory: ./nextjs-frontend
        run: |
          echo "üîç Computing build hash for change detection..."

          # Create hash of all files in out directory
          BUILD_HASH=$(find out -type f -exec sha256sum {} \; | sort -k 2 | sha256sum | cut -d' ' -f1)
          echo "build-hash=${BUILD_HASH}" >> $GITHUB_OUTPUT
          echo "üìù Build hash: ${BUILD_HASH}"

          # Save manifest with file hashes
          echo "{" > out/_deployment-manifest.json
          echo "  \"build_hash\": \"${BUILD_HASH}\"," >> out/_deployment-manifest.json
          echo "  \"build_time\": \"$(date -Iseconds)\"," >> out/_deployment-manifest.json
          echo "  \"commit_sha\": \"${{ github.sha }}\"," >> out/_deployment-manifest.json
          echo "  \"workflow_run\": \"${{ github.run_id }}\"," >> out/_deployment-manifest.json
          echo "  \"files\": {" >> out/_deployment-manifest.json

          # Generate file hashes
          FIRST=true
          find out -type f ! -name '_deployment-manifest.json' | sort | while read file; do
            HASH=$(sha256sum "$file" | cut -d' ' -f1)
            REL_PATH=${file#out/}
            if [ "$FIRST" = true ]; then
              echo "    \"${REL_PATH}\": \"${HASH}\"" >> out/_deployment-manifest.json
              FIRST=false
            else
              echo "    ,\"${REL_PATH}\": \"${HASH}\"" >> out/_deployment-manifest.json
            fi
          done

          echo "  }" >> out/_deployment-manifest.json
          echo "}" >> out/_deployment-manifest.json

          echo "‚úÖ Manifest created"

      # Check if deployment needed (incremental mode)
      - name: Check for changes
        id: check-changes
        working-directory: ./nextjs-frontend
        env:
          DEPLOYMENT_TYPE: ${{ inputs.deployment_type || 'incremental' }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          if [ "$DEPLOYMENT_TYPE" = "full" ]; then
            echo "needs-deploy=true" >> $GITHUB_OUTPUT
            echo "üöÄ Full deployment requested - skipping change detection"
            exit 0
          fi

          echo "üîç Checking for changes since last deployment..."

          # Try to fetch last deployment manifest from KV
          # Note: This requires a Worker to expose KV via API
          # For now, we'll always deploy in incremental mode
          # Future enhancement: Store manifest in KV and compare

          echo "needs-deploy=true" >> $GITHUB_OUTPUT
          echo "üìù Changes detected - deployment needed"

      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: ./nextjs-frontend/out
          retention-days: 7
          compression-level: 6

  # Deploy job - uploads to Cloudflare
  deploy:
    name: Deploy to Cloudflare Pages
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: needs.build.outputs.needs-deploy == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Download build artifacts
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: ./nextjs-frontend/out

      # Deploy to Cloudflare Pages with retry logic (static HTML only)
      - name: Deploy to Cloudflare Pages
        id: deploy
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./nextjs-frontend/out --project-name=saa-static --branch=main --commit-dirty=true
        continue-on-error: true

      # Retry deployment on failure (attempt 2)
      - name: Retry deployment (attempt 2)
        if: steps.deploy.outcome == 'failure'
        id: deploy-retry-2
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./nextjs-frontend/out --project-name=saa-static --branch=main --commit-dirty=true
        continue-on-error: true

      # Retry deployment on failure (attempt 3)
      - name: Retry deployment (attempt 3)
        if: steps.deploy-retry-2.outcome == 'failure'
        id: deploy-retry-3
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./nextjs-frontend/out --project-name=saa-static --branch=main --commit-dirty=true

      # Set deployment status
      - name: Set deployment status
        if: always()
        id: set-status
        run: |
          if [ "${{ steps.deploy.outcome }}" = "success" ] || \
             [ "${{ steps.deploy-retry-2.outcome }}" = "success" ] || \
             [ "${{ steps.deploy-retry-3.outcome }}" = "success" ]; then
            echo "‚úÖ Deployment successful"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "DEPLOY_STATUS=success" >> $GITHUB_ENV
          else
            echo "‚ùå Deployment failed after 3 attempts"
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "DEPLOY_STATUS=failed" >> $GITHUB_ENV
            exit 1
          fi

      # Store deployment manifest in KV (optional - requires Worker setup)
      - name: Store deployment manifest
        if: success()
        continue-on-error: true
        run: |
          echo "üìù Storing deployment manifest..."

          # Future enhancement: Upload manifest to Workers KV
          # This requires a Worker endpoint to accept the manifest
          # curl -X POST "https://saabuildingblocks.com/api/store-manifest" \
          #   -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          #   -d @./nextjs-frontend/out/_deployment-manifest.json

          echo "‚ö†Ô∏è  Manifest storage not implemented yet (requires Worker setup)"

  # Notification job - sends webhook to n8n
  notify:
    name: Send Deployment Notification
    needs: [build, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always()

    steps:
      - name: Prepare notification payload
        id: prepare-payload
        run: |
          # Determine overall status
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            STATUS="success"
            MESSAGE="‚úÖ Deployment completed successfully"
          elif [ "${{ needs.deploy.result }}" = "failure" ]; then
            STATUS="failed"
            MESSAGE="‚ùå Deployment failed"
          elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
            STATUS="skipped"
            MESSAGE="‚è≠Ô∏è  Deployment skipped (no changes detected)"
          else
            STATUS="cancelled"
            MESSAGE="üö´ Deployment cancelled"
          fi

          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "message=${MESSAGE}" >> $GITHUB_OUTPUT

          # Create JSON payload
          cat > payload.json <<EOF
          {
            "status": "${STATUS}",
            "message": "${MESSAGE}",
            "post_id": "${{ github.event.client_payload.post_id || inputs.post_id || '' }}",
            "post_slug": "${{ github.event.client_payload.post_slug || inputs.post_slug || '' }}",
            "deployment_url": "https://saa-static.pages.dev",
            "production_url": "https://static.smartagentalliance.com",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "workflow_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "build_hash": "${{ needs.build.outputs.build-hash }}",
            "triggered_by": "${{ github.event_name }}",
            "actor": "${{ github.actor }}",
            "timestamp": "$(date -Iseconds)"
          }
          EOF

          echo "üìù Notification payload prepared"
          cat payload.json

      # Send notification to n8n webhook
      - name: Send notification webhook
        if: secrets.N8N_WEBHOOK_URL != ''
        continue-on-error: true
        run: |
          echo "üì§ Sending notification to n8n webhook..."

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.N8N_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d @payload.json)

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "‚úÖ Notification sent successfully (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è  Notification failed (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
          fi

      # Create GitHub deployment status
      - name: Update GitHub deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.prepare-payload.outputs.status }}';
            const message = '${{ steps.prepare-payload.outputs.message }}';

            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: status === 'success' ? 'success' : status === 'failed' ? 'failure' : 'inactive',
              description: message,
              environment_url: 'https://static.smartagentalliance.com',
              log_url: `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            }).catch(err => {
              console.log('Note: Could not create deployment status (no deployment found)');
            });

            // Add comment to commit with deployment status
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `
            ## üöÄ Cloudflare Deployment ${status === 'success' ? '‚úÖ' : '‚ùå'}

            **Status:** ${message}
            **Build Hash:** \`${{ needs.build.outputs.build-hash }}\`
            **Deployment URL:** https://saa-static.pages.dev
            **Production URL:** https://static.smartagentalliance.com
            **Workflow Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            ${status === 'failed' ? '‚ö†Ô∏è Check the workflow logs for error details.' : ''}
              `.trim()
            }).catch(err => {
              console.log('Note: Could not create commit comment');
            });
