name: Deploy to Cloudflare Pages

"on":
  # Trigger from n8n workflow
  repository_dispatch:
    types: [deploy-wordpress-content]

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      post_id:
        description: 'WordPress Post ID'
        required: false
      post_slug:
        description: 'WordPress Post Slug'
        required: false
      deployment_type:
        description: 'Deployment type'
        required: false
        default: 'incremental'
        type: choice
        options:
          - incremental
          - full
      deployment_id:
        description: 'WordPress Deployment ID'
        required: false
      triggered_by:
        description: 'Trigger source'
        required: false
        default: 'manual'

env:
  NODE_VERSION: '20'
  CLOUDFLARE_PROJECT_NAME: 'saabuildingblocks'  # Static export project
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes in seconds
  MAX_PARALLEL_UPLOADS: 100  # Increased from 50 for faster uploads
  RETRY_ATTEMPTS: 3
  RETRY_DELAY: 2  # Reduced from 5s to 2s for faster retries

jobs:
  # Build job - creates the static export
  build:
    name: Build Static Export
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      build-hash: ${{ steps.compute-hash.outputs.build-hash }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      # Install dependencies (monorepo root) with caching
      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies (with npm cache enabled)..."
          npm ci --prefer-offline --no-audit

      # NEW: Type check BEFORE building to catch ALL errors at once
      - name: Type Check (Catch all errors upfront)
        run: |
          echo "ðŸ” Running TypeScript type check..."
          echo "   This will show ALL type errors at once (not just the first one)"
          echo ""
          
          cd packages/public-site
          npm run type-check || {
            echo ""
            echo "âŒ Type errors found above. Fix these before the build will succeed."
            exit 1
          }
          
          echo "âœ… Type check passed"

      # Generate static CSS (file is gitignored, so generate fresh on each deploy)
      - name: Generate static CSS
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          echo "ðŸŽ¨ Generating static CSS from Master Controller..."
          cd packages/public-site

          # Generate CSS using the build-time script
          npm run generate:css

          if [ -f "public/static-master-controller.css" ]; then
            echo "âœ… Static CSS generated successfully"
            ls -lh public/static-master-controller.css
          else
            echo "âš ï¸  Static CSS not generated, proceeding without it"
          fi

      # Clean Next.js cache before build
      - name: Clean Next.js cache
        run: |
          echo "ðŸ§¹ Cleaning Next.js build cache..."
          cd packages/public-site
          rm -rf .next out
          echo "âœ… Cache cleaned"

      # Build static export (FROM MONOREPO ROOT - fixes tsconfig resolution)
      - name: Build Static Export
        env:
          NODE_ENV: production
          # Use properly formatted placeholder values (API routes excluded from export)
          NEXT_PUBLIC_SUPABASE_URL: "https://placeholder.supabase.co"
          NEXT_PUBLIC_SUPABASE_ANON_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NzUyNjUyMDAsImV4cCI6MTk5MDg0MTIwMH0.cXVhY2toIHdvcmthcm91bmQ"
          SUPABASE_SERVICE_ROLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY3NTI2NTIwMCwiZXhwIjoxOTkwODQxMjAwfQ.c2VydmljZSByb2xlIGtleQ"
          # WordPress API for blog content
          WORDPRESS_API_URL: ${{ secrets.WORDPRESS_API_URL }}
          NEXT_PUBLIC_WORDPRESS_API_URL: ${{ secrets.NEXT_PUBLIC_WORDPRESS_API_URL }}
          # WordPress credentials for authenticated API access
          WORDPRESS_USER: ${{ secrets.WORDPRESS_USER }}
          WORDPRESS_APP_PASSWORD: ${{ secrets.WORDPRESS_APP_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building static export for Cloudflare Pages"
          echo "   Config: next.config.ts (already has output: 'export')"
          echo "   Build context: Monorepo root (fixes tsconfig resolution)"
          echo "   âœ… FIXED: Turbopack can now resolve '../../tsconfig.json'"
          echo ""

          # cd into package directory and build
          cd packages/public-site
          npx next build

          # Quick verification
          [ -d "out/_next" ] && [ -f "out/index.html" ] || { echo "âŒ Build failed"; exit 1; }
          echo "âœ… Build complete: $(find out -type f | wc -l) files, $(du -sh out/ | cut -f1)"

      # Compute simple build hash (for tracking only)
      - name: Compute build hash
        id: compute-hash
        working-directory: packages/public-site
        run: |
          # Simple hash based on commit + build time (no per-file hashing needed)
          BUILD_HASH="${{ github.sha }}-$(date +%s)"
          echo "build-hash=${BUILD_HASH}" >> $GITHUB_OUTPUT
          echo "ðŸ“ Build: ${BUILD_HASH}"

      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: packages/public-site/out
          retention-days: 7
          compression-level: 6

  # Deploy job - uploads to Cloudflare
  deploy:
    name: Deploy to Cloudflare Pages
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      # Download build artifacts
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: packages/public-site/out

      # Setup Node.js (caching disabled for guaranteed fresh builds)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      # Install Wrangler globally
      - name: Install Wrangler
        run: |
          if ! command -v wrangler &> /dev/null; then
            echo "ðŸ“¦ Installing Wrangler..."
            npm install -g wrangler@latest
          else
            echo "âœ… Wrangler already installed: $(wrangler --version)"
          fi

      # Deploy to Cloudflare Pages with retry logic
      - name: Deploy to Cloudflare Pages
        id: deploy
        working-directory: packages/public-site
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Retry logic in bash (simpler than multiple workflow steps)
          for attempt in 1 2 3; do
            echo "ðŸš€ Deployment attempt $attempt/3..."
            # Run from packages/public-site/ so wrangler detects ./functions directory
            if wrangler pages deploy ./out --project-name=saabuildingblocks --branch=main --commit-dirty=true; then
              echo "âœ… Deployment successful on attempt $attempt"
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            [ $attempt -lt 3 ] && echo "â³ Retrying in 2s..." && sleep 2
          done
          echo "âŒ Deployment failed after 3 attempts"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
