name: Deploy to Cloudflare Pages

on:
  # Trigger from n8n workflow
  repository_dispatch:
    types: [deploy-wordpress-content]

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      post_id:
        description: 'WordPress Post ID'
        required: false
      post_slug:
        description: 'WordPress Post Slug'
        required: false
      deployment_type:
        description: 'Deployment type'
        required: false
        default: 'incremental'
        type: choice
        options:
          - incremental
          - full
      skip_build_cache:
        description: 'Skip build cache'
        required: false
        default: false
        type: boolean
      deployment_id:
        description: 'WordPress Deployment ID'
        required: false
      triggered_by:
        description: 'Trigger source'
        required: false
        default: 'manual'

env:
  NODE_VERSION: '20'
  CLOUDFLARE_PROJECT_NAME: 'saabuildingblocks'  # Static export project
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes in seconds
  MAX_PARALLEL_UPLOADS: 50
  RETRY_ATTEMPTS: 3
  RETRY_DELAY: 5

jobs:
  # Build job - creates the static export
  build:
    name: Build Static Export
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      build-hash: ${{ steps.compute-hash.outputs.build-hash }}
      needs-deploy: ${{ steps.check-changes.outputs.needs-deploy }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      # Cache node_modules (monorepo root + packages)
      - name: Cache node_modules
        if: ${{ !inputs.skip_build_cache }}
        uses: actions/cache@v4
        id: node-modules-cache
        with:
          path: |
            node_modules
            packages/*/node_modules
          key: ${{ runner.os }}-node-modules-nextjs16-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-nextjs16-

      # Cache Next.js build
      - name: Cache Next.js build
        if: ${{ !inputs.skip_build_cache }}
        uses: actions/cache@v4
        with:
          path: |
            packages/public-site/.next/cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('package-lock.json') }}-${{ hashFiles('packages/public-site/**/*.js', 'packages/public-site/**/*.jsx', 'packages/public-site/**/*.ts', 'packages/public-site/**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('package-lock.json') }}-
            ${{ runner.os }}-nextjs-

      # Install dependencies (monorepo root)
      - name: Install dependencies
        run: |
          if [ "${{ steps.node-modules-cache.outputs.cache-hit }}" != "true" ]; then
            echo "ðŸ“¦ Installing dependencies (fresh install)..."
            npm ci --prefer-offline --no-audit
          else
            echo "âœ… Using cached node_modules"
          fi

          # Verify Next.js version in public-site package
          echo "ðŸ” Verifying Next.js version..."
          cd packages/public-site
          NEXTJS_VERSION=$(npm list next --depth=0 --json 2>/dev/null | jq -r '.dependencies.next.version // empty')

          if [ -z "$NEXTJS_VERSION" ]; then
            echo "âš ï¸  Next.js not found in package dependencies"
          else
            echo "   Installed: Next.js v${NEXTJS_VERSION}"

            if [[ "${NEXTJS_VERSION}" != "16."* ]]; then
              echo "âš ï¸  Next.js version mismatch! Expected 16.x, got ${NEXTJS_VERSION}"
            fi
          fi

      # NEW: Type check BEFORE building to catch ALL errors at once
      - name: Type Check (Catch all errors upfront)
        run: |
          echo "ðŸ” Running TypeScript type check..."
          echo "   This will show ALL type errors at once (not just the first one)"
          echo ""
          
          cd packages/public-site
          npm run type-check || {
            echo ""
            echo "âŒ Type errors found above. Fix these before the build will succeed."
            exit 1
          }
          
          echo "âœ… Type check passed"

      # Generate static CSS and copy component files
      - name: Generate static CSS and components
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          echo "ðŸŽ¨ Generating static CSS and copying component files..."
          echo "   Source: packages/shared/components/saa/"
          echo "   Destination: packages/public-site/public/"

          cd packages/public-site
          npm run generate:css

          # Verify CSS was generated
          if [ -f "public/static-master-controller.css" ]; then
            echo "âœ… CSS file generated successfully"
            ls -lh public/static-master-controller.css
          else
            echo "âŒ CSS generation failed!"
            exit 1
          fi

          # Verify components were copied
          if [ -d "public/components" ]; then
            COMPONENT_COUNT=$(find public/components -type f | wc -l)
            echo "âœ… Components copied successfully (${COMPONENT_COUNT} files)"
            echo "   Components will be available at /components/ in static export"
          else
            echo "âš ï¸  No components directory found (non-fatal)"
          fi

      # Build static export (FROM MONOREPO ROOT - fixes tsconfig resolution)
      - name: Build Static Export
        env:
          NODE_ENV: production
          # Use properly formatted placeholder values (API routes excluded from export)
          NEXT_PUBLIC_SUPABASE_URL: "https://placeholder.supabase.co"
          NEXT_PUBLIC_SUPABASE_ANON_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NzUyNjUyMDAsImV4cCI6MTk5MDg0MTIwMH0.cXVhY2toIHdvcmthcm91bmQ"
          SUPABASE_SERVICE_ROLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY3NTI2NTIwMCwiZXhwIjoxOTkwODQxMjAwfQ.c2VydmljZSByb2xlIGtleQ"
          # WordPress API for blog content
          WORDPRESS_API_URL: ${{ secrets.WORDPRESS_API_URL }}
          NEXT_PUBLIC_WORDPRESS_API_URL: ${{ secrets.NEXT_PUBLIC_WORDPRESS_API_URL }}
          # WordPress credentials for authenticated API access
          WORDPRESS_USER: ${{ secrets.WORDPRESS_USER }}
          WORDPRESS_APP_PASSWORD: ${{ secrets.WORDPRESS_APP_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building static export for Cloudflare Pages"
          echo "   Config: next.config.ts (already has output: 'export')"
          echo "   Build context: Monorepo root (fixes tsconfig resolution)"
          echo "   âœ… FIXED: Turbopack can now resolve '../../tsconfig.json'"
          echo ""

          # cd into package directory (but build runs from monorepo root context)
          cd packages/public-site

          # Clean previous builds
          rm -rf out .next

          # Build with Next.js (Turbopack resolves tsconfig from monorepo root)
          echo "ðŸ—ï¸  Building with Next.js 16 static export..."
          npx next build

          echo ""
          echo "ðŸ“Š Build verification:"
          echo "  Files to deploy: $(find out -type f | wc -l)"
          echo "  Total size: $(du -sh out/ | cut -f1)"

          # Verify critical files exist
          if [ ! -d "out/_next" ]; then
            echo "âŒ _next directory missing - build failed"
            exit 1
          fi

          if [ ! -f "out/index.html" ]; then
            echo "âŒ index.html missing - build failed"
            exit 1
          fi

          if [ ! -f "out/static-master-controller.css" ]; then
            echo "âš ï¸  CSS missing (non-fatal - may use default styles)"
          fi

          echo ""
          echo "  Sample HTML files:"
          find out -type f -name "*.html" | head -10
          echo ""
          echo "âœ… Static export complete - ready for Cloudflare Pages deployment"

      # Compute build hash for change detection
      - name: Compute build hash
        id: compute-hash
        working-directory: packages/public-site
        run: |
          echo "ðŸ” Computing build hash for change detection..."
          
          # Create hash of all files in out directory
          BUILD_HASH=$(find out -type f -exec sha256sum {} \; | sort -k 2 | sha256sum | cut -d' ' -f1)
          echo "build-hash=${BUILD_HASH}" >> $GITHUB_OUTPUT
          echo "ðŸ“ Build hash: ${BUILD_HASH}"
          
          # Save manifest with file hashes
          echo "{" > out/_deployment-manifest.json
          echo "  \"build_hash\": \"${BUILD_HASH}\"," >> out/_deployment-manifest.json
          echo "  \"build_time\": \"$(date -Iseconds)\"," >> out/_deployment-manifest.json
          echo "  \"commit_sha\": \"${{ github.sha }}\"," >> out/_deployment-manifest.json
          echo "  \"workflow_run\": \"${{ github.run_id }}\"," >> out/_deployment-manifest.json
          echo "  \"files\": {" >> out/_deployment-manifest.json
          
          # Generate file hashes
          FIRST=true
          find out -type f ! -name '_deployment-manifest.json' | sort | while read file; do
            HASH=$(sha256sum "$file" | cut -d' ' -f1)
            REL_PATH=${file#out/}
            if [ "$FIRST" = true ]; then
              echo "    \"${REL_PATH}\": \"${HASH}\"" >> out/_deployment-manifest.json
              FIRST=false
            else
              echo "    ,\"${REL_PATH}\": \"${HASH}\"" >> out/_deployment-manifest.json
            fi
          done
          
          echo "  }" >> out/_deployment-manifest.json
          echo "}" >> out/_deployment-manifest.json
          
          echo "âœ… Manifest created"

      # Check if deployment needed (incremental mode)
      - name: Check for changes
        id: check-changes
        working-directory: packages/public-site
        env:
          DEPLOYMENT_TYPE: ${{ inputs.deployment_type || 'incremental' }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          if [ "$DEPLOYMENT_TYPE" = "full" ]; then
            echo "needs-deploy=true" >> $GITHUB_OUTPUT
            echo "ðŸš€ Full deployment requested - skipping change detection"
            exit 0
          fi
          
          echo "ðŸ” Checking for changes since last deployment..."
          
          # Try to fetch last deployment manifest from KV
          # Note: This requires a Worker to expose KV via API
          # For now, we'll always deploy in incremental mode
          # Future enhancement: Store manifest in KV and compare
          
          echo "needs-deploy=true" >> $GITHUB_OUTPUT
          echo "ðŸ“ Changes detected - deployment needed"

      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: packages/public-site/out
          retention-days: 7
          compression-level: 6

  # Deploy job - uploads to Cloudflare
  deploy:
    name: Deploy to Cloudflare Pages
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: needs.build.outputs.needs-deploy == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Download build artifacts
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: packages/public-site/out

      # Deploy to Cloudflare Pages with retry logic (static HTML only)
      - name: Deploy to Cloudflare Pages
        id: deploy
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy packages/public-site/out --project-name=saabuildingblocks --branch=main --commit-dirty=true
        continue-on-error: true

      # Retry deployment on failure (attempt 2)
      - name: Retry deployment (attempt 2)
        if: steps.deploy.outcome == 'failure'
        id: deploy-retry-2
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy packages/public-site/out --project-name=saabuildingblocks --branch=main --commit-dirty=true
        continue-on-error: true

      # Retry deployment on failure (attempt 3)
      - name: Retry deployment (attempt 3)
        if: steps.deploy-retry-2.outcome == 'failure'
        id: deploy-retry-3
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy packages/public-site/out --project-name=saabuildingblocks --branch=main --commit-dirty=true

      # Set deployment status
      - name: Set deployment status
        if: always()
        id: set-status
        run: |
          if [ "${{ steps.deploy.outcome }}" = "success" ] || \
             [ "${{ steps.deploy-retry-2.outcome }}" = "success" ] || \
             [ "${{ steps.deploy-retry-3.outcome }}" = "success" ]; then
            echo "âœ… Deployment successful"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "DEPLOY_STATUS=success" >> $GITHUB_ENV
          else
            echo "âŒ Deployment failed after 3 attempts"
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "DEPLOY_STATUS=failed" >> $GITHUB_ENV
            exit 1
          fi

      # Store deployment manifest in KV (optional - requires Worker setup)
      - name: Store deployment manifest
        if: success()
        continue-on-error: true
        run: |
          echo "ðŸ“ Storing deployment manifest..."
          
          # Future enhancement: Upload manifest to Workers KV
          # This requires a Worker endpoint to accept the manifest
          # curl -X POST "https://saabuildingblocks.com/api/store-manifest" \
          #   -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          #   -d @packages/public-site/out/_deployment-manifest.json
          
          echo "âš ï¸  Manifest storage not implemented yet (requires Worker setup)"

  # Notification job - sends webhook to n8n
  notify:
    name: Send Deployment Notification
    needs: [build, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always()

    steps:
      - name: Prepare notification payload
        id: prepare-payload
        run: |
          # Determine overall status
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            STATUS="success"
            MESSAGE="âœ… Deployment completed successfully"
          elif [ "${{ needs.deploy.result }}" = "failure" ]; then
            STATUS="failed"
            MESSAGE="âŒ Deployment failed"
          elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
            STATUS="skipped"
            MESSAGE="â­ï¸  Deployment skipped (no changes detected)"
          else
            STATUS="cancelled"
            MESSAGE="ðŸš« Deployment cancelled"
          fi
          
          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "message=${MESSAGE}" >> $GITHUB_OUTPUT
          
          # Create JSON payload
          cat > payload.json <<EOF
          {
            "status": "${STATUS}",
            "message": "${MESSAGE}",
            "post_id": "${{ github.event.client_payload.post_id || inputs.post_id || '' }}",
            "post_slug": "${{ github.event.client_payload.post_slug || inputs.post_slug || '' }}",
            "deployment_url": "https://saabuildingblocks.pages.dev",
            "production_url": "https://static.smartagentalliance.com",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "workflow_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "build_hash": "${{ needs.build.outputs.build-hash }}",
            "triggered_by": "${{ github.event_name }}",
            "actor": "${{ github.actor }}",
            "timestamp": "$(date -Iseconds)"
          }
          EOF
          
          echo "ðŸ“ Notification payload prepared"
          cat payload.json

      # Send notification to n8n webhook
      - name: Send notification webhook
        continue-on-error: true
        run: |
          echo "ðŸ“¤ Sending notification to n8n webhook..."
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.N8N_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d @payload.json)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "âœ… Notification sent successfully (HTTP $HTTP_CODE)"
          else
            echo "âš ï¸  Notification failed (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
          fi

      # Send status back to WordPress
      - name: Notify WordPress
        if: always()
        continue-on-error: true
        run: |
          DEPLOYMENT_ID="${{ github.event.inputs.deployment_id }}"
          STATUS="${{ steps.prepare-payload.outputs.status }}"
          
          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "â„¹ï¸  No deployment ID provided, skipping WordPress notification"
            exit 0
          fi
          
          echo "ðŸ“¤ Sending deployment status to WordPress..."
          echo "   Deployment ID: $DEPLOYMENT_ID"
          echo "   Status: $STATUS"
          
          # Prepare error message if deployment failed
          ERROR_MESSAGE=""
          if [ "$STATUS" = "failed" ]; then
            ERROR_MESSAGE="Deployment failed after 3 attempts. Check GitHub Actions logs for details."
          fi
          
          # Send webhook to WordPress
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.WORDPRESS_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "deployment_id": "'"$DEPLOYMENT_ID"'",
              "status": "'"$STATUS"'",
              "build_hash": "${{ needs.build.outputs.build-hash }}",
              "github_run_id": "${{ github.run_id }}",
              "github_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
              "cloudflare_deployment_url": "https://saabuildingblocks.pages.dev",
              "commit_sha": "${{ github.sha }}",
              "error_message": "'"$ERROR_MESSAGE"'",
              "timestamp": "'"$(date -Iseconds)"'"
            }')
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "âœ… WordPress notified successfully (HTTP $HTTP_CODE)"
          else
            echo "âš ï¸  WordPress notification failed (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
          fi

      # Create GitHub deployment status
      - name: Update GitHub deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.prepare-payload.outputs.status }}';
            const message = '${{ steps.prepare-payload.outputs.message }}';
            
            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: status === 'success' ? 'success' : status === 'failed' ? 'failure' : 'inactive',
              description: message,
              environment_url: 'https://static.smartagentalliance.com',
              log_url: `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            }).catch(err => {
              console.log('Note: Could not create deployment status (no deployment found)');
            });
            
            // Add comment to commit with deployment status
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `
            ## ðŸš€ Cloudflare Deployment ${status === 'success' ? 'âœ…' : 'âŒ'}
            
            **Status:** ${message}
            **Build Hash:** \`${{ needs.build.outputs.build-hash }}\`
            **Deployment URL:** https://saabuildingblocks.pages.dev
            **Production URL:** https://static.smartagentalliance.com
            **Workflow Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            
            ${status === 'failed' ? 'âš ï¸ Check the workflow logs for error details.' : ''}
              `.trim()
            }).catch(err => {
              console.log('Note: Could not create commit comment');
            });
