name: Deploy to Cloudflare Pages

"on":
  # Auto-deploy on push to main (runs in parallel with CI)
  push:
    branches:
      - main
    paths:
      - 'packages/public-site/**'
      - 'packages/shared/**'
      - '.github/workflows/deploy-cloudflare.yml'

  # Trigger from n8n workflow
  repository_dispatch:
    types: [deploy-wordpress-content]

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      post_id:
        description: 'WordPress Post ID'
        required: false
      post_slug:
        description: 'WordPress Post Slug'
        required: false
      deployment_type:
        description: 'Deployment type'
        required: false
        default: 'incremental'
        type: choice
        options:
          - incremental
          - full
      deployment_id:
        description: 'WordPress Deployment ID'
        required: false
      triggered_by:
        description: 'Trigger source'
        required: false
        default: 'manual'

concurrency:
  group: cloudflare-deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '20'
  CLOUDFLARE_PROJECT_NAME: 'saabuildingblocks'  # Static export project
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes in seconds
  MAX_PARALLEL_UPLOADS: 100  # Increased from 50 for faster uploads
  RETRY_ATTEMPTS: 3
  RETRY_DELAY: 2  # Reduced from 5s to 2s for faster retries

jobs:
  # Build job - creates the static export
  build:
    name: Build Static Export
    runs-on: ubuntu-latest
    timeout-minutes: 6

    outputs:
      build-hash: ${{ steps.compute-hash.outputs.build-hash }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection
          token: ${{ secrets.GITHUB_TOKEN }}

      # SAFETY CHECK: Verify critical functions files match live deployment
      - name: Verify functions/ files match live deployment
        run: |
          echo "üîí Safety Check: Verifying critical functions match live deployment..."
          echo ""

          # Critical file to verify
          LOCAL_FILE="packages/public-site/functions/[slug].js"
          LIVE_URL="https://saabuildingblocks.pages.dev/doug-smart"

          if [ ! -f "$LOCAL_FILE" ]; then
            echo "‚ùå CRITICAL: $LOCAL_FILE not found in repo!"
            exit 1
          fi

          # Extract a unique identifier from local file
          LOCAL_MARKER=$(grep -o "Scroll-Triggered 3D Card Stack\|Why Only at eXp Section -->" "$LOCAL_FILE" | head -1)

          # Fetch live page and check for the same marker (with timeout to prevent hanging)
          echo "üì° Fetching live deployment to verify..."
          LIVE_CONTENT=$(curl -s --connect-timeout 5 --max-time 15 "$LIVE_URL" | head -5000) || echo "Warning: Could not fetch live site"

          if echo "$LIVE_CONTENT" | grep -q "$LOCAL_MARKER"; then
            echo "‚úÖ Verified: Local [slug].js matches live deployment"
            echo "   Marker found: $LOCAL_MARKER"
          else
            echo "‚ö†Ô∏è  WARNING: Local [slug].js may differ from live deployment!"
            echo "   Expected marker: $LOCAL_MARKER"
            echo ""
            echo "   This could mean:"
            echo "   1. The repo has an outdated [slug].js"
            echo "   2. A manual deployment updated live without committing"
            echo ""
            echo "   To fix: Ensure local functions/ matches what's currently live"
            echo "   Then commit: git add packages/public-site/functions/ && git commit"
            echo ""
            echo "   Proceeding anyway (marker check is advisory)..."
          fi
          echo ""

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      # Cache node_modules for faster installs
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            packages/*/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      # Install dependencies (monorepo root) with caching
      - name: Install dependencies
        run: |
          echo "üì¶ Installing dependencies (with npm cache enabled)..."
          npm ci --prefer-offline --no-audit

      # Cache shared package build
      - name: Cache shared package build
        uses: actions/cache@v4
        with:
          path: packages/shared/dist
          key: shared-build-${{ hashFiles('packages/shared/**/*.ts', 'packages/shared/**/*.tsx') }}
          restore-keys: |
            shared-build-

      # Build shared package first (required for type checking other packages)
      - name: Build shared package
        run: |
          echo "üî® Building shared package..."
          cd packages/shared
          npm run build
          echo "‚úÖ Shared package built"

      # Cache Next.js build for faster rebuilds
      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: |
            packages/public-site/.next/cache
          key: nextjs-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('packages/public-site/**/*.js', 'packages/public-site/**/*.jsx', 'packages/public-site/**/*.ts', 'packages/public-site/**/*.tsx') }}
          restore-keys: |
            nextjs-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-
            nextjs-${{ runner.os }}-

      # Type check BEFORE building to catch ALL errors at once
      - name: Type Check (Catch all errors upfront)
        run: |
          echo "üîç Running TypeScript type check..."
          echo "   This will show ALL type errors at once (not just the first one)"
          echo ""
          
          cd packages/public-site
          npm run type-check || {
            echo ""
            echo "‚ùå Type errors found above. Fix these before the build will succeed."
            exit 1
          }
          
          echo "‚úÖ Type check passed"

      # Generate static CSS (non-fatal ‚Äî falls back to committed version if Supabase is unreachable)
      - name: Generate static CSS
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          cd packages/public-site

          if npm run generate:css 2>&1; then
            echo "Static CSS generated fresh from Supabase"
            ls -lh public/static-master-controller.css
          elif [ -f "public/static-master-controller.css" ]; then
            echo "Supabase unreachable ‚Äî using committed CSS fallback"
            ls -lh public/static-master-controller.css
          else
            echo "No CSS available ‚Äî build will proceed without Master Controller styles"
          fi

      # Clean Next.js cache before build
      - name: Clean Next.js cache
        run: |
          echo "üßπ Cleaning Next.js build cache..."
          cd packages/public-site
          rm -rf .next out
          echo "‚úÖ Cache cleaned"

      # Build static export (FROM MONOREPO ROOT - fixes tsconfig resolution)
      - name: Build Static Export
        env:
          NODE_ENV: production
          # Use properly formatted placeholder values (API routes excluded from export)
          NEXT_PUBLIC_SUPABASE_URL: "https://placeholder.supabase.co"
          NEXT_PUBLIC_SUPABASE_ANON_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NzUyNjUyMDAsImV4cCI6MTk5MDg0MTIwMH0.cXVhY2toIHdvcmthcm91bmQ"
          SUPABASE_SERVICE_ROLE_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY3NTI2NTIwMCwiZXhwIjoxOTkwODQxMjAwfQ.c2VydmljZSByb2xlIGtleQ"
          # WordPress API for blog content
          WORDPRESS_API_URL: ${{ secrets.WORDPRESS_API_URL }}
          NEXT_PUBLIC_WORDPRESS_API_URL: ${{ secrets.NEXT_PUBLIC_WORDPRESS_API_URL }}
          # WordPress credentials for authenticated API access
          WORDPRESS_USER: ${{ secrets.WORDPRESS_USER }}
          WORDPRESS_APP_PASSWORD: ${{ secrets.WORDPRESS_APP_PASSWORD }}
        run: |
          echo "üî® Building static export for Cloudflare Pages"
          echo "   Config: next.config.ts (already has output: 'export')"
          echo "   Build context: Monorepo root (fixes tsconfig resolution)"
          echo "   ‚úÖ FIXED: Turbopack can now resolve '../../tsconfig.json'"
          echo ""

          # cd into package directory and build
          cd packages/public-site
          npx next build

          # Quick verification
          [ -d "out/_next" ] && [ -f "out/index.html" ] || { echo "‚ùå Build failed"; exit 1; }
          echo "‚úÖ Build complete: $(find out -type f | wc -l) files, $(du -sh out/ | cut -f1)"

      # Compute simple build hash (for tracking only)
      - name: Compute build hash
        id: compute-hash
        working-directory: packages/public-site
        run: |
          # Simple hash based on commit + build time (no per-file hashing needed)
          BUILD_HASH="${{ github.sha }}-$(date +%s)"
          echo "build-hash=${BUILD_HASH}" >> $GITHUB_OUTPUT
          echo "üìù Build: ${BUILD_HASH}"

      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: packages/public-site/out
          retention-days: 7
          compression-level: 6

  # Deploy job - uploads to Cloudflare
  deploy:
    name: Deploy to Cloudflare Pages
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Download build artifacts
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: packages/public-site/out

      # Setup Node.js (caching disabled for guaranteed fresh builds)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      # Install Wrangler globally
      - name: Install Wrangler
        run: |
          if ! command -v wrangler &> /dev/null; then
            echo "üì¶ Installing Wrangler..."
            npm install -g wrangler@latest
          else
            echo "‚úÖ Wrangler already installed: $(wrangler --version)"
          fi

      # Deploy to Cloudflare Pages with retry logic
      - name: Deploy to Cloudflare Pages
        id: deploy
        working-directory: packages/public-site
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Sanitize commit message (remove emojis and non-ASCII for Cloudflare API)
          COMMIT_MSG=$(git log -1 --pretty=%s | LC_ALL=C tr -cd '[:print:]' | head -c 100)
          [ -z "$COMMIT_MSG" ] && COMMIT_MSG="Deploy from GitHub Actions"
          echo "üìù Commit message: $COMMIT_MSG"

          # Retry logic in bash (simpler than multiple workflow steps)
          for attempt in 1 2 3; do
            echo "üöÄ Deployment attempt $attempt/3..."
            # Run from packages/public-site/ so wrangler detects ./functions directory
            if wrangler pages deploy ./out --project-name=saabuildingblocks --branch=main --commit-dirty=true --commit-message="$COMMIT_MSG"; then
              echo "‚úÖ Deployment successful on attempt $attempt"
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            [ $attempt -lt 3 ] && echo "‚è≥ Retrying in 2s..." && sleep 2
          done
          echo "‚ùå Deployment failed after 3 attempts"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1

      # Purge Cloudflare cache to ensure new deployment is immediately visible
      - name: Purge Cloudflare Cache
        if: steps.deploy.outputs.status == 'success'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "üßπ Purging Cloudflare cache for production domain..."
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}' \
            && echo "‚úÖ Cache purged successfully" \
            || echo "‚ö†Ô∏è  Cache purge failed, but deployment succeeded"
